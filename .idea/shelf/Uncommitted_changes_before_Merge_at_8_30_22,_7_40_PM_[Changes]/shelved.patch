Index: dataclasses/tilerow.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\n\n\nclass TileRow:\n\n    def __init__(self, number_of_squares: int, type):\n        \"\"\"\n        Initializer of the tile row\n        :param number_of_squares: An integer representing the number of squares in the row\n        \"\"\"\n        self.tiles = []\n        self.tile_color = None\n        self.number_of_squares = number_of_squares\n        self.rect = None\n        self.type = type\n\n    def show(self, screen, x, y):\n        \"\"\"\n        The method to draw the row and tiles on the screen\n        :param screen: The pygame display that the row will display on\n        :param x: The upper left-hand corner x-coordinate\n        :param y: The upper left-hand corner y-coordinate\n        :return: None\n        \"\"\"\n        # create a rectangle of space\n        # place squares starting at the right end\n        color = (200, 200, 200)\n        for i in range(self.number_of_squares):\n            pygame.draw.rect(screen, color, pygame.Rect(x + 2 + (4 - i) * 33, y + 1, 32, 32), 2)\n            if i < len(self.tiles):\n                self.tiles[i].show(screen, x + 2 + (4 - i) * 33, y + 1)\n        self.rect = pygame.Rect(x + 2 + (5 - self.number_of_squares) * 33 + 2, y, 33 * self.number_of_squares + 4, 34)\n\n    def accept_tiles(self, tiles):\n        \"\"\"\n        Handler for adding new tiles to the row\n        :param tiles: A list of tiles that need to go to the row\n        :return: tiles that don't fit on the row.\n        \"\"\"\n        overflow_tiles = []\n        print(self.type)\n        if self.type == \"collect\":\n            print(\"HERE\")\n            if self.tile_color:\n                print(\"here???\")\n                if self.tile_color != tiles[0].color and tiles[0].color != \"first\":\n                    raise ValueError(\"Wrong color.\")\n            else:\n                print(\"is it first\" + tiles[0].color)\n                if tiles[0].color == \"first\":\n                    overflow_tiles = [tiles[0]]\n                    del tiles[0]\n                    print(tiles[0].color)\n                self.tile_color = tiles[0].color\n            squares_remaining = self.number_of_squares - len(self.tiles)\n            # TODO: Look out for 1st player tile.\n            if len(tiles) < squares_remaining:\n                self.tiles += tiles\n            else:\n                self.tiles += tiles[:squares_remaining]\n                for tile in tiles[squares_remaining:]:\n                    overflow_tiles.append(tile)\n            return overflow_tiles\n        else:\n            squares_remaining = self.number_of_squares - len(self.tiles)\n            if len(tiles) < squares_remaining:\n                self.tiles +=tiles\n\n    def flush_tiles(self):\n        \"\"\"\n        Send tiles back\n        :return: tiles on the row\n        \"\"\"\n        old_tiles = list(self.tiles)\n        self.tiles = []\n        self.tile_color = None\n        return old_tiles\n\n    def is_full(self):\n        \"\"\"\n        Test if the row is full\n        :return: boolean that indicates if full\n        \"\"\"\n        return self.number_of_squares == len(self.tiles)\n\n    def collide_tile_row(self, x, y):\n        \"\"\"\n        Is a coordinate inside the row.\n        :param x:\n        :param y:\n        :return:\n        \"\"\"\n        return self.rect.collidepoint(x, y)\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dataclasses/tilerow.py b/dataclasses/tilerow.py
--- a/dataclasses/tilerow.py	(revision d9a4fb0f71c719acf56797fb59e649e21d58615e)
+++ b/dataclasses/tilerow.py	(date 1661899207985)
@@ -13,6 +13,9 @@
         self.number_of_squares = number_of_squares
         self.rect = None
         self.type = type
+        self.colors = ['blue','yellow','red','black','teal']
+        if self.type == "display":
+            self.tiles = [None, None, None, None, None]
 
     def show(self, screen, x, y):
         """
@@ -27,8 +30,13 @@
         color = (200, 200, 200)
         for i in range(self.number_of_squares):
             pygame.draw.rect(screen, color, pygame.Rect(x + 2 + (4 - i) * 33, y + 1, 32, 32), 2)
-            if i < len(self.tiles):
-                self.tiles[i].show(screen, x + 2 + (4 - i) * 33, y + 1)
+            if self.type == "display":
+                for i in range(5):
+                    if self.tiles[i] is not None:
+                        self.tiles[i].show(screen, (x-2-(4-i)*33)+135, y+1)
+            else:
+                if i < len(self.tiles):
+                    self.tiles[i].show(screen, x + 2 + (4 - i) * 33, y + 1)
         self.rect = pygame.Rect(x + 2 + (5 - self.number_of_squares) * 33 + 2, y, 33 * self.number_of_squares + 4, 34)
 
     def accept_tiles(self, tiles):
@@ -53,7 +61,6 @@
                     print(tiles[0].color)
                 self.tile_color = tiles[0].color
             squares_remaining = self.number_of_squares - len(self.tiles)
-            # TODO: Look out for 1st player tile.
             if len(tiles) < squares_remaining:
                 self.tiles += tiles
             else:
@@ -66,6 +73,23 @@
             if len(tiles) < squares_remaining:
                 self.tiles +=tiles
 
+    def display_tiles(self, tile, row):
+        if self.type == "display":
+            for i in range(5):
+                if tile.color == self.colors[i]:
+                    print(row+i)
+                    if row+i <= 4:
+                        y = i + row
+                        del self.tiles[y]
+                        self.tiles.insert(y, tile)
+                        #print(self.tiles)
+                    else:
+                        y = row-(5-i)
+                        del self.tiles[y]
+                        self.tiles.insert(y, tile)
+                        #print(y)
+
+
     def flush_tiles(self):
         """
         Send tiles back
Index: dataclasses/player.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from dataclasses.collectionarea import CollectionArea\nfrom dataclasses.overflow import Overflow\n\nclass Player:\n    \"\"\"\n    A class to hold information about a player.\n\n    There are two class variables. These are to make it so that each player has a different color.\n    \"\"\"\n    colors = [(255, 0, 0), (0, 255, 0), (0, 0, 255), (255, 255, 0)]\n    count = 0\n\n    def __init__(self, name):\n        self.name = name\n        self.next_player = None\n        self.score = 0\n        self.player_color = Player.colors[Player.count % 4]\n        Player.count += 1\n        self.collection_area = CollectionArea()\n        self.overflow = Overflow()\n        # self.tile_wall=TileWall()\n\n    def add_next_player(self, player):\n        \"\"\"\n        Give information about which player is next.\n        :param player:\n        :return: None\n        \"\"\"\n        self.next_player = player\n\n    def get_next_player(self):\n        \"\"\"\n        Get the next player.\n        :return: Player that comes next.\n        \"\"\"\n        return self.next_player\n\n    def get_score(self):\n        \"\"\"\n        Gets the score.\n        :return: (int) the score\n        \"\"\"\n        return self.score\n\n    def add_to_score(self, amount):\n        \"\"\"\n        Change the current score of a player\n        :param amount: The amount to increase the score\n        :return: the adjusted the score of player\n        \"\"\"\n        self.score += amount\n        return self.score\n\n    def show(self, display, x, y):\n        \"\"\"\n        Show the player board setup  with a collection area, the tile wall and the overflow area\n        :param display: The display that the player board is to be shown on\n        :param x: The x coordinate of the upper left-hand corner\n        :param y: The y coordinate of the upper left-hand corner\n        :return: None\n        \"\"\"\n\n        self.collection_area.show(display, x, y)\n        self.overflow.show(display, x, y+200)\n        # self.tile_wall(display, x+300, y)\n        # self.overflow(display, x, y+400)\n\n    def listen(self, event):\n        # listen for the collection area\n        row = self.collection_area.listen(event)\n        if row:\n            return (\"row\", row)\n        return (\"none\", None)\n\n    def place_overflow(self, tiles):\n        if tiles != None:\n            self.overflow.placeTile(tiles)\n\nif __name__ == \"__main__\":\n    play1 = Player(\"Bob\")\n    play2 = Player(\"Shirley\")\n    print(str(play1.player_color))\n    print(str(play2.player_color))\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dataclasses/player.py b/dataclasses/player.py
--- a/dataclasses/player.py	(revision d9a4fb0f71c719acf56797fb59e649e21d58615e)
+++ b/dataclasses/player.py	(date 1661886386627)
@@ -1,6 +1,6 @@
 from dataclasses.collectionarea import CollectionArea
 from dataclasses.overflow import Overflow
-
+from dataclasses.tilewall import Tile_Wall
 class Player:
     """
     A class to hold information about a player.
@@ -18,6 +18,7 @@
         Player.count += 1
         self.collection_area = CollectionArea()
         self.overflow = Overflow()
+        self.tilewall = Tile_Wall()
         # self.tile_wall=TileWall()
 
     def add_next_player(self, player):
@@ -62,8 +63,7 @@
 
         self.collection_area.show(display, x, y)
         self.overflow.show(display, x, y+200)
-        # self.tile_wall(display, x+300, y)
-        # self.overflow(display, x, y+400)
+        self.tilewall.show(display, x+200, y)
 
     def listen(self, event):
         # listen for the collection area
Index: dataclasses/tilewall.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/dataclasses/tilewall.py b/dataclasses/tilewall.py
new file mode 100644
--- /dev/null	(date 1661902688200)
+++ b/dataclasses/tilewall.py	(date 1661902688200)
@@ -0,0 +1,46 @@
+import pygame
+from dataclasses.tilerow import TileRow
+from dataclasses.tile import Tile
+
+
+# from dataclasses.screens import screen
+
+
+class Tile_Wall():
+    def __init__(self):
+        self.rect = None
+        self.tiles = []
+        self.image = pygame.image.load('img/Tile Wall.png')
+        self.rows = []
+        self.colors = ['blue', 'yellow', 'red', 'black', 'teal']
+        self.create_tilerows()
+
+    def create_tilerows(self):
+        for i in range(5):
+            tile_row = TileRow(5, "display")
+            self.rows.append(tile_row)
+        for i in range(5):
+            new_tile = Tile('tile wall', 'black', 'img/Black_Tile.png', 101)
+            #self.rows[i].display_tiles(new_tile, i)
+
+    def show(self, screen, x, y):
+        self.rect = screen.blit(self.image, (x, y))
+        offset_y = 2
+        for tile_row in self.rows:
+            # print('here^^^^^')
+            tile_row.show(screen, x + 2, y + offset_y)
+            offset_y += 36
+
+    def place_tiles(self, row, tile):
+        for i in range(5):
+            if tile.color == self.colors[i]:
+                for x in range(5):
+                    if row == x:
+                        if x + i <= 4:
+                            y = x + i
+                            del self.rows[x][y]
+                            self.rows[x].insert(tile, y)
+                        else:
+                            y = x - (4 - i)
+                            del self.rows[x][y]
+                            self.rows[x].insert(tile, y)
